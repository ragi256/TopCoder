#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <limits>
#include <tuple>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

void debug(vector<int> dp, vector<int> times){
	    cout << "    dp:    ";
	    for(int i=0; i<dp.size(); i++)
	    	cout << dp[i] << "  ";
	    cout << endl;
	    cout << " times:    ";
	    for(int i=0; i<dp.size(); i++)
	    	cout << times[i] << "  ";
	    cout << endl;
}


class ThePriceIsRight {
public:
	vector <int> howManyReveals(vector <int> prices) {
	    vector<int> dp(prices.size(), 0);
	    vector<int> times(prices.size(), 1);;
	    dp[0]=1; times[0]=1;
	    for(int i=1; i<prices.size() ; ++i){
		for(int j=0; j<i; j++){
		    if(prices[j] < prices[i]){
			if(dp[i] < dp[j]){
			    dp[i] = dp[j];
			    times[i] = times[j];
			}
			else if(dp[i] == dp[j]){
			    times[i] += times[j];
			}
		    }
		}
		dp[i]++;
	    }
	    debug(dp, times);
	    int maximum = *max_element(dp.begin(), dp.end());
	    int time=0; 
	    for(int i=0; i<dp.size(); ++i){
		if(dp[i] == maximum)
		    time += times[i];
	    }
	    vector<int> result;
	    result.push_back(maximum);
	    result.push_back(time);
	    return result;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, vector <int> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		if(p0[i] < 10)
		    cout << " " << p0[i];
		else
		    cout <<p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	ThePriceIsRight *obj;
	vector <int> answer;
	obj = new ThePriceIsRight();
	clock_t startTime = clock();
	answer = obj->howManyReveals(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
		if (hasAnswer) {
			cout << "Desired answer:" << endl;
			cout << "\t" << "{";
			for (int i = 0; int(p1.size()) > i; ++i) {
				if (i > 0) {
					cout << ",";
				}
				cout << p1[i];
			}
			cout << "}" << endl;
		}
		cout << "Your answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(answer.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << answer[i];
		}
		cout << "}" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <int> p0;
	vector <int> p1;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {30,10,20,40,50};
	p1 = {4,1};
	all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {39,88,67, 5,69,87,82,64,58,61};
	p1 = {4,2};
	all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = { 1, 2, 3, 4, 5, 6, 7, 8, 9,10};
	p1 = {10,1};
	all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
	p1 = {1,10};
	all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {29,31,73,70,14, 5, 6,34,53,30,15,86};
	p1 = {5,2};
	all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = {100,99, 1, 2, 3};
	p1 = {3,1};
	all_right = (disabled || KawigiEdit_RunTest(5, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 6 -----
	disabled = false;
	p0 = {10,20,11,12};
	p1 = {3,1};
	all_right = (disabled || KawigiEdit_RunTest(6, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// The Price Is Right is a television game show. In the final round of competition, the contestant is shown the prizes which he can win. To win everything, he must make an educated guess and arrange the prizes in increasing order of price.
// 
// Once the contestant has completed ordering prizes, the host begins to reveal the price of each prize in any order that he wishes. To make the show more interesting however, the host reveals prices in such a way that as many prices are revealed as possible before an error in the order is revealed.
// 
// Each element in prices represents the price of a prize. The order of prices represents what the contestant thought the order was when arranging prices.
// 
// Given a vector <int> of prices as ordered by the contestant, return a vector <int> with two elements. The first element should be the maximum possible number of prices revealed before the order of prices is broken, while the second element should be the total number of ways of achieving that maximum number.
// 
// For example, prices = {30, 10, 20, 40, 50}
// The host could reveal the following prices: 30 * * 40 50. The next price revealed (either 10 or 20) will cause an error in the ordering to be revealed. In this case, 3 prices were revealed. Alternatively, the host could reveal the following prices: * 10 20 40 50. Once again, the next price revealed will cause an error in the ordering to be revealed. However, in this case, 4 prices were revealed and thus the host would prefer to reveal the prices this way. Note that there is only 1 way of revealing 4 prices. The method should return {4,1}.
// 
// 
// DEFINITION
// Class:ThePriceIsRight
// Method:howManyReveals
// Parameters:vector <int>
// Returns:vector <int>
// Method signature:vector <int> howManyReveals(vector <int> prices)
// 
// 
// NOTES
// -The host DOES NOT work out any intermediate deductions. He reveals prices until the sequence order is broken. See examples 5 and 6.
// 
// 
// CONSTRAINTS
// -prices will have between 1 and 50 elements inclusive.
// -prices will not have any repeated elements.
// -each element in prices will be between 1 and 1000000 inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {30,10,20,40,50}
// 
// Returns: { 4,  1 }
// 
// See above.
// 
// 1)
// {39,88,67,5,69,87,82,64,58,61}
// 
// Returns: { 4,  2 }
// 
// The maximum number of prices that can be revealed is 4, and there are 2 ways of achieving it. The host could either reveal 39 * 67 * 69 87 * * * * or 39 * 67 * 69 * 82 * * *. The method should return {4,2}.
// 
// 2)
// {1,2,3,4,5,6,7,8,9,10}
// 
// Returns: { 10,  1 }
// 
// 3)
// {10,9,8,7,6,5,4,3,2,1}
// 
// Returns: { 1,  10 }
// 
// 4)
// {29,31,73,70,14,5,6,34,53,30,15,86}
// 
// Returns: { 5,  2 }
// 
// The host could either reveal 29 31 * * * * * 34 53 * * 86 or * * * * * 5 6 34 53 * * 86. The method should return {5,2}
// 
// 5)
// {100,99,1,2,3}
// 
// Returns: { 3,  1 }
// 
// In theory, because elements in prices are at least 1 (due to constraints), it is enough to reveal any of 1, 2 or 3 to know that the sequence of prices is broken. However, the host DOES NOT make these intermediate deductions and will reveal * * 1 2 3.
// 
// 
// 6)
// {10,20,11,12}
// 
// Returns: { 3,  1 }
// 
// In theory, because there can be no price between 10 and 11, it is enough to reveal both 10 and 11 to know that the sequence of prices is broken. However, the host DOES NOT make these intermediate deductions and will reveal 10 * 11 12.
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
