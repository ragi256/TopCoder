#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <limits>
#include <tuple>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

#define _USE_MATH_DEFINES
constexpr double EPS = numeric_limits<double>::epsilon();
const double PI = M_PI;


class Topping{
public:
    int x, y;
    double r, theta;
    bool cut;
    Topping(int a, int b){
	x = a; y = b;
	r = sqrt(a*a + b*b);
	theta = acos(x/r);
	cut = false;
    }
};

bool cuttable(double axis, vector<Topping> &toppings){
    bool symmetry = true;
    for(int i=0; i<toppings.size(); ++i){\
	bool find = false;
	Topping &tpp1 = toppings[i];
	double angle = tpp1.theta - axis;
	double sym_theta = axis + (angle > 0 ? -angle : angle);
	double radius = tpp1.r;
	Topping sym_tpp(radius*cos(sym_theta), radius*sin(sym_theta));
	for(int j=0; j<toppings.size(); ++j){
	    Topping &tpp2 = toppings[j];
	    double dx = abs(sym_tpp.x-tpp2.x), dy = abs(sym_tpp.y-tpp2.y);
	    if(dx<EPS && dy<EPS) find = true;
	    if(find) break;
	}
	if(!find){
	    symmetry = false;
	    break;
	}
    }
    return symmetry;
}

void cut(double axis, vector<Topping> &toppings, int num){
    for(int i=num; i<toppings.size(); ++i){
	if(abs(toppings[i].theta - axis) < EPS)
	    toppings[i].cut = true;
    }
}

class PizzaDivision {
public:
	int howMany(vector <string> toppings) {
	    int res = 0;
	    vector<Topping> vi_toppings;
	    vector<double> cut_ed;
	    for(int i=0; i<toppings.size(); ++i){
		int x, y;
		istringstream iss(toppings[i]);
		iss >> x >> y;
		Topping temp(x, y);
		vi_toppings.push_back(temp);
	    }
	    if(vi_toppings.size()==1){
		Topping check = vi_toppings[0];
		if(check.x==0 && check.y==0) return -1;
		else return 1;
	    }
	    for(int i=0; i<vi_toppings.size(); ++i){
		if(vi_toppings[i].cut) continue;
		double axis = vi_toppings[i].theta;
		if(find(cut_ed.begin(), cut_ed.end(), axis)!=cut_ed.end()) continue;
		if(cuttable(axis, vi_toppings)){
		    cout << axis << endl;
		    ++res;
		    cut(axis, vi_toppings, i);
		    cut_ed.push_back(axis);
		}
		double normal = axis < PI ? axis+PI/2 : axis-PI/2;
		if(find(cut_ed.begin(), cut_ed.end(), normal)!=cut_ed.end()) continue;
		if(cuttable(normal, vi_toppings)){
		    cout << "\t" <<axis << endl;
		    ++res;
		    cut(normal, vi_toppings, i);
		    cut_ed.push_back(normal);
		}
	    }
	    return res;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	PizzaDivision *obj;
	int answer;
	obj = new PizzaDivision();
	clock_t startTime = clock();
	answer = obj->howMany(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
		if (hasAnswer) {
			cout << "Desired answer:" << endl;
			cout << "\t" << p1 << endl;
		}
		cout << "Your answer:" << endl;
		cout << "\t" << answer << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <string> p0;
	int p1;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {"0 110","0 70","-75 20","75 20","-25 -50","25 -50"};
	p1 = 1;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {"0 70","70 0","0 -70","-70 0"};
	p1 = 4;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {"0 0"};
	p1 = -1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {"3 -4"};
	p1 = 1;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {"3 -4","-3 4"};
	p1 = 2;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = {"1 2","3 4"};
	p1 = 0;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 6 -----
	disabled = false;
	p0 = {"-300 100","-200 100","-100 100","100 100","200 100","300 100","-300 -100","-200 -100","-100 -100","100 -100","200 -100","300 -100"};
	p1 = 2;
	all_right = (disabled || KawigiEdit_RunTest(6, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 7 -----
	disabled = false;
	p0 = {"-54 -83","-46 54","-5 -44","-1 -31","-14 47","7 -5","-45 -63","-88 47","-17 -9","-26 -66","40 56","-67 69","-49 -2","2 62","61 78","-81 -32","87 33","-22 -53","-43 -38","57 28","35 12","-53 -15","52 -16","32 -44","-73 68","79 44","3 56","-66 26","-87 41","4 87","22 53","59 16","-3 55","3 19","-26 8","43 38","54 46","-16 22","-3 -93","45 63","0 -37","-7 5","-40 -56","40 19","-8 -63","-16 -89","29 11","-52 -21","-58 -22","4 -61"};
	p1 = 1;
	all_right = (disabled || KawigiEdit_RunTest(7, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You want to divide a round pizza (represented by a circle) into two equal halves with one straight cut. The pizza contains several toppings, represented by points strictly inside the circle. The cut is called beautiful if the two halves of the pizza are mirror images of each other: for every topping in one half there is a topping in the other half in the symmetric point (we don't care about the toppings that are exactly on the cut).
// 
// For example, the cut represented by the red line in the following picture is the only beautiful cut for that pizza (black dots are toppings):
// 
// 
// This pizza has four different beautiful cuts, all shown by red lines:
// 
// 
// You are to count the number of different beautiful cuts for a given pizza. You are given a String[] toppings, each element representing a topping in the form "x y", where x and y are the coordinates of that topping. You may assume that the pizza is large enough to have all those toppings inside. The point of origin coincides with the center of the pizza (that is, the center of the pizza has the coordinates "0 0"). Return the number of different beautiful cuts, or -1 if there are infinitely many of them.
// 
// DEFINITION
// Class:PizzaDivision
// Method:howMany
// Parameters:vector <string>
// Returns:int
// Method signature:int howMany(vector <string> toppings)
// 
// 
// NOTES
// -Two points A and B are symmetric with respect to line L, if and only if either A and B coincide and lie on L or L is perpendicular to AB and crosses it in its middle point.
// 
// 
// CONSTRAINTS
// -toppings will contain between 1 and 50 elements, inclusive.
// -Each element of toppings will be formatted as "x y" (quotes for clarity only), where x and y are integers between -500 and 500, inclusive, with no extra leading zeroes.
// -All elements of toppings will be different.
// 
// 
// EXAMPLES
// 
// 0)
// {"0 110", "0 70", "-75 20", "75 20", "-25 -50", "25 -50"}
// 
// Returns: 1
// 
// The first example from the problem statement.
// 
// 1)
// {"0 70", "70 0", "0 -70", "-70 0"}
// 
// Returns: 4
// 
// The second example from the problem statement.
// 
// 2)
// {"0 0"}
// 
// Returns: -1
// 
// Any cut passing through the center suffices.
// 
// 3)
// {"3 -4"}
// 
// Returns: 1
// 
// 
// 
// 4)
// {"3 -4", "-3 4"}
// 
// Returns: 2
// 
// 
// 
// 5)
// {"1 2", "3 4"}
// 
// Returns: 0
// 
// 
// 
// 6)
// {"-300 100", "-200 100", "-100 100", "100 100", 
// "200 100", "300 100", "-300 -100", "-200 -100", 
// "-100 -100", "100 -100", "200 -100", "300 -100"}
// 
// Returns: 2
// 
// 
// 
// 7)
// {"-54 -83", "-46 54", "-5 -44", "-1 -31", "-14 47", 
// "7 -5", "-45 -63", "-88 47", "-17 -9", "-26 -66", 
// "40 56", "-67 69", "-49 -2", "2 62", "61 78", 
// "-81 -32", "87 33", "-22 -53", "-43 -38", "57 28", 
// "35 12", "-53 -15", "52 -16", "32 -44", "-73 68", 
// "79 44", "3 56", "-66 26", "-87 41", "4 87", 
// "22 53", "59 16", "-3 55", "3 19", "-26 8", 
// "43 38", "54 46", "-16 22", "-3 -93", "45 63", 
// "0 -37", "-7 5", "-40 -56", "40 19", "-8 -63", 
// "-16 -89", "29 11", "-52 -21", "-58 -22", "4 -61"}
// 
// Returns: 1
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
