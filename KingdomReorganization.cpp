#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <limits>
#include <tuple>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

int Kingdom[50][50]={};
int Build[50][50]={};
int Destroy[50][50]={};

void debug(int size){
    string line(90, '-');
    for(int i=0; i<size; ++i){
	for(int j=0; j<size; ++j)
	    cerr << Kingdom[i][j] << " ";
	cerr << endl;
    }
    cerr << line << endl;
    for(int i=0; i<size; ++i){
	for(int j=0; j<size; ++j)
	    cerr << Build[i][j] << " ";
	cerr << endl;
    }
    cerr << line << endl;
    for(int i=0; i<size; ++i){
	for(int j=0; j<size; ++j)
	    cerr << Destroy[i][j] << " ";
	cerr << endl;
    }
    string line2(90, '=');
    cerr << line2 << endl;
}

class Edge{
public:
    int num_x;
    int num_y;
    int cost;
    Edge(const int& x, const int& y, const int& z){
	num_x=x; num_y=y; cost=z;
    }
};

class comp{
    bool reverse;
public:
    comp(const bool& revparam=false){
	reverse=revparam;
    }
    bool operator()(const Edge& lhs, const Edge& rhs)const{
	if(reverse) return (lhs.cost>rhs.cost);
	else return (lhs.cost<rhs.cost);
    }
};
typedef priority_queue<Edge, vector<Edge>, comp> kingdom_pq;

int input(const char x){
    if(x > 'z')
	return x - 'A';
    else
	return x - 'a' + 26;
}

class KingdomReorganization {
public:
	int getCost(vector <string> kingdom, vector <string> build, vector <string> destroy) {
	    int result=0;
	    for(int i=0; i<kingdom.size(); ++i){
		for(int j=0; j<kingdom[i].size(); ++j){
		    if(kingdom[i][j]=='1')
			Kingdom[i][j]=1;
		    
		    Build[i][j] = input(build[i][j]);
		    Destroy[i][j] = input(build[i][j]);
		}
	    }
	    kingdom_pq qu(comp(true));
	    set<int> reach;

	    // ルートを落とす

	    for(int i=0; i<kingdom.size(); ++i){
		for(int j=0; j<kingdom[i].size(); ++j){
		    if()
	    	    else{
	    		Edge temp(i, j, Build[i][j]);
	    		qu.push(temp);
	    	    }
	    	}
	    }
	    cout <<"reach size: " << reach.size() << endl;
	    cout <<"qu size: " << qu.size() << endl;
	    while(reach.size()==kingdom.size()){
		Edge next=qu.top();
		//行ける点の見つけ方が違う
		if(reach.find(next.num_x)==reach.end()){
		    if(reach.find(next.num_y)==reach.end()){
			reach.insert(next.num_x);
			reach.insert(next.num_y);
		    }
		}
		result += next.cost;
		qu.pop();
	    }
	    return result;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, vector <string> p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p2[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	KingdomReorganization *obj;
	int answer;
	obj = new KingdomReorganization();
	clock_t startTime = clock();
	answer = obj->getCost(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
		if (hasAnswer) {
			cout << "Desired answer:" << endl;
			cout << "\t" << p3 << endl;
		}
		cout << "Your answer:" << endl;
		cout << "\t" << answer << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <string> p0;
	vector <string> p1;
	vector <string> p2;
	int p3;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {"000","000","000"};
	p1 = {"ABD","BAC","DCA"};
	p2 = {"ABD","BAC","DCA"};
	p3 = 3;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {"011","101","110"};
	p1 = {"ABD","BAC","DCA"};
	p2 = {"ABD","BAC","DCA"};
	p3 = 1;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {"011000","101000","110000","000011","000101","000110"};
	p1 = {"ABDFFF","BACFFF","DCAFFF","FFFABD","FFFBAC","FFFDCA"};
	p2 = {"ABDFFF","BACFFF","DCAFFF","FFFABD","FFFBAC","FFFDCA"};
	p3 = 7;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {"0"};
	p1 = {"A"};
	p2 = {"A"};
	p3 = 0;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {"0001","0001","0001","1110"};
	p1 = {"AfOj","fAcC","OcAP","jCPA"};
	p2 = {"AWFH","WAxU","FxAV","HUVA"};
	p3 = 0;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = {"0000000000","0000000011","0001010000","0010010000","0000001000","0011000000","0000100000","0000000011","0100000101","0100000110"};
	p1 = {"AhPEqkSFMM","hAfKPtsDad","PfAyGQkaqN","EKyAeLpRpm","qPGeASfNwo","ktQLSAnCAK","SskpfnAdJS","FDaRNCdAZz","MaqpwAJZAn","MdNmoKSznA"};
	p2 = {"AgTqWWxEYH","gAXPgjzIRA","TXAleTmWvT","qPlAQkwxRO","WgeQAqgbJJ","WjTkqAiTzl","xzmwgiAuHb","EIWxbTuAwk","YRvRJzHwAn","HATOJlbknA"};
	p3 = 65;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// This problem statement contains subscripts and may not be shown properly outside of the applet.
// 
// The greatest king of all times, Michael IV, is going to make big changes in his kingdom. The kingdom is composed of N cities (for simplicity numbered from 0 to N-1). Some pairs of cities are connected by bidirectional roads. We say that there is a path between different cities A and B if there exists a sequence of unique cities {C1, C2, ..., CM}, such that C1 = A and CM = B and for each index i < M, there is a road between cities Ci and Ci+1.
// 
// The current state of the kingdom is miserable. Some pairs of cities are not connected by any path. On the other hand, other pairs of cities are connected by multiple different paths, and that leads to complicated traffic routing. Michael wants to build some new roads and destroy some of the already existing roads in the kingdom so that after the reconstruction there will exist exactly one path between every pair of distinct cities. As building new roads and destroying old ones costs a lot of money, Michael wants to minimize the total cost spent on the reconstruction.
// 
// You are given a vector <string> kingdom describing the current state of the kingdom. There is a road between the cities i and j if and only if kingdom[i][j] = '1' and kingdom[j][i] = '1'. You are also given a vector <string> build and a vector <string> destroy. If no road exists between cities i and j, then the cost of building it is encoded by build[i][j]. If there already is a road between cities i and j, then the cost of destroying it is encoded by destroy[i][j]. The costs in both vector <string>s are encoded as characters, where 'A', 'B', ..., 'Z' represent the costs 0, 1, ..., 25, respectively and 'a', 'b', ..., 'z' represent the costs 26, 27, ..., 51, respectively. Your task is to find and return the minimal cost needed for the kingdom reconstruction.
// 
// DEFINITION
// Class:KingdomReorganization
// Method:getCost
// Parameters:vector <string>, vector <string>, vector <string>
// Returns:int
// Method signature:int getCost(vector <string> kingdom, vector <string> build, vector <string> destroy)
// 
// 
// NOTES
// -N, the number of cities in the kingdom can be determined as the number of elements of kingdom.
// -Two paths {A1, A2, ..., AR} and {B1, B2, ..., BS} are considered different if either R is not equal to S or there exists i <= R, such that Ai is not equal to Bi.
// -There can never exist a road leading from some city to itself.
// -The values in build that correspond to existing roads can simply be ignored. Similarly, ignore the values in destroy that correspond to nonexistent roads.
// 
// 
// CONSTRAINTS
// -N will be between 1 and 50, inclusive.
// -kingdom, build and destroy will each contain N elements.
// -Each of the elements of kingdom, build and destroy will contain N characters.
// -Each character in each element of kingdom will be either '0' or '1'.
// -For each i, kingdom[i][i] will be '0'.
// -For each i and j, kingdom[i][j] will be equal to kingdom[j][i].
// -Each character in each element of build and destroy will be either an uppercase letter ('A'-'Z') or a lowercase letter ('a'-'z').
// -For each i, build[i][i] and destroy[i][i] will be 'A'.
// -For each i and j, build[i][j] will be equal to build[j][i].
// -For each i and j, destroy[i][j] will be equal to destroy[j][i].
// 
// 
// EXAMPLES
// 
// 0)
// {"000","000","000"}
// {"ABD","BAC","DCA"}
// {"ABD","BAC","DCA"}
// 
// Returns: 3
// 
// There are three cities in the kingdom, totally disconnected. 
// The only optimal solution is to build the roads between cities 0-1 (cost 1) and 1-2 (cost 2).
// 
// 1)
// {"011","101","110"}
// {"ABD","BAC","DCA"}
// {"ABD","BAC","DCA"}
// 
// Returns: 1
// 
// Now the three cities form a connected triangle and we need to destroy one road. 
// Optimal solution is to destroy the road between the cities 0-1 (cost 1).
// 
// 2)
// {"011000","101000","110000","000011","000101","000110"}
// {"ABDFFF","BACFFF","DCAFFF","FFFABD","FFFBAC","FFFDCA"}
// {"ABDFFF","BACFFF","DCAFFF","FFFABD","FFFBAC","FFFDCA"}
// 
// Returns: 7
// 
// We have six cities forming two separate triangles. 
// Like in the Example 1, destroy one road in each triangle (costs 1 for each road) and then join the triangles by a new road (costs 5).
// 
// 3)
// {"0"}
// {"A"}
// {"A"}
// 
// Returns: 0
// 
// One city is okay just as it is.
// 
// 4)
// {"0001","0001","0001","1110"}
// {"AfOj","fAcC","OcAP","jCPA"}
// {"AWFH","WAxU","FxAV","HUVA"}
// 
// Returns: 0
// 
// We have four cities, which are connected in such a way that there is exactly one path between each two cities. 
// Thus there is nothing to reconstruct.
// 
// 5)
// {"0000000000","0000000011","0001010000","0010010000","0000001000","0011000000","0000100000","0000000011","0100000101","0100000110"}
// {"AhPEqkSFMM","hAfKPtsDad","PfAyGQkaqN","EKyAeLpRpm","qPGeASfNwo","ktQLSAnCAK","SskpfnAdJS","FDaRNCdAZz","MaqpwAJZAn","MdNmoKSznA"}
// {"AgTqWWxEYH","gAXPgjzIRA","TXAleTmWvT","qPlAQkwxRO","WgeQAqgbJJ","WjTkqAiTzl","xzmwgiAuHb","EIWxbTuAwk","YRvRJzHwAn","HATOJlbknA"}
// 
// Returns: 65
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
