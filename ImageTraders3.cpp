#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <limits>
#include <tuple>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;
#define rep(i,n) for(int i=0;i<(int)(n);i++)

int mem[16][10][1 << 15];

class ImageTraders {
    int N;
    vector<int> P[20];
// k:owner p:now_price b:status
    int saiki(int k, int p, int b){
	if(mem[k][p][b] != -1) return mem[k][p][b];

	int ma = 1;
	rep (i, N){
	    if ((b >> i) & 1) continue;
	    if (P[k][i] >= p)
		ma = max(1 + saiki(i, P[k][i], b | (1 << i)), ma);
	}
	return mem[k][p][b] = ma;
    }
public:
	int maxOwners(vector <string> price) {
	    N = price.size();
	    rep(i,N){
		P[i].resize(N);
		rep(j,N) P[i][j] = price[i][j] - '0';
	    }
	    memset(mem, -1, sizeof(mem));
	    return saiki(0,0,1);
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	ImageTraders *obj;
	int answer;
	obj = new ImageTraders();
	clock_t startTime = clock();
	answer = obj->maxOwners(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
		if (hasAnswer) {
			cout << "Desired answer:" << endl;
			cout << "\t" << p1 << endl;
		}
		cout << "Your answer:" << endl;
		cout << "\t" << answer << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <string> p0;
	int p1;

	// ----- test 3 -----
	disabled = false;
	p0 = {"15555","11111","15111","11111","11111"};
	p1 = 3;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 0 -----
	disabled = false;
	p0 = {"4447631759621", "7857418597538", "8318964333860", "4888977643030", "9254059469224", "7754812893680", "2105110850646", "2586284724062", "9908131103403", "9196933805664", "0046267569872", "8299602761321", "5991491075870"};
	p1 = 13;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {"777777777777778", "777777777777774", "777777777777771", "777777777777772", "777777777777770", "777777777777771", "777777777777772", "777777777777774", "777777777777773", "777777777777774", "777777777777776", "777777777777773", "777777777777771", "777777777777774", "766647667677767"};
	p1 = 14;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {"01231","00231","00031","00002","00000"};
	p1 = 4;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	
	// ----- test 4 -----
	disabled = false;
	p0 = {"623321417825392", "100112100101002", "002120222020201", "021112000221102", "112122012022120", "202021002221111", "000020020212222", "020100020210022", "002001112110122", "122200202221010", "210221202221200", "220011100112221", "202001120112210", "020121200212011", "102210022002000"};
	p1 = 15;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// There is a community of art lovers who meet from time to time and trade images with each other.  Each image transaction must obey the following rules:
// 
// The price at which the image is sold must be greater than or equal to the price at which it was bought.
// No trader is allowed to buy the same image more than once.
// 
// 
// A new image has just appeared on the market.  Trader 0 bought it from an unknown artist for the price of '0', and he is now ready to trade it among his fellow art lovers.  You are given a vector <string> price, where the j-th character of the i-th element is a digit representing the price at which trader j will buy the image from trader i.  '0' is the lowest price, and '9' is the highest.  Assuming all transactions obey the rules mentioned above, determine the longest possible sequence of transactions involving the new image.  After all the transactions are done, return the number of people who have owned the image at some point in time, including both the final owner and trader 0.
// 
// 
// DEFINITION
// Class:ImageTraders
// Method:maxOwners
// Parameters:vector <string>
// Returns:int
// Method signature:int maxOwners(vector <string> price)
// 
// 
// CONSTRAINTS
// -price will contain exactly N elements, where N is between 2 and 15, inclusive.
// -Each element of price will contain exactly N characters.
// -Each element of price will contain only digits ('0'-'9').
// 
// 
// EXAMPLES
// 
// 0)
// {
// "01",
// "10"
// }
// 
// Returns: 2
// 
// Trader 0 can sell the image to trader 1 for the price of '1'.  Both traders were owners of the image, so the answer is 2.
// 
// 1)
// {
// "022",
// "101",
// "110"
// }
// 
// 
// Returns: 2
// 
// We have 3 traders here. Trader 0 can sell the image to either trader 1 or trader 2 for the price of '2'.  In both cases, the buyer would have to sell the image for a price of at least '2', which is impossible.  Therefore, the maximal number of owners is 2.
// 
// 2)
// {
// "01231",
// "00231",
// "00031",
// "00002",
// "00000"
// }
// 
// Returns: 4
// 
// Here the image can have 4 owners:
// 
// Trader 0 sells the image to trader 1 for the price of '1'.
// Trader 1 sells the image to trader 2 for the price of '2'.
// Trader 2 sells the image to trader 3 for the price of '3'.
// 
// 
// 3)
// {
// "15555",
// "11111",
// "15111",
// "11111",
// "11111"
// }
// 
// Returns: 3
// 
// Trader 0 can sell the image to trader 2 for the price of '5'.  Then, trader 2 can sell it to trader 1.
// 
// 4)
// {
// "0100000000",
// "0020000000",
// "0003000000",
// "0000400000",
// "0000050000",
// "0000006000",
// "0000000700",
// "0000000080",
// "0000000009",
// "1111111111"
// }
// 
// Returns: 10
// 
// The image can be traded among all the traders in the following sequence: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
