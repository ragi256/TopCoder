#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <limits>
#include <tuple>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

// ひとつ隣にズレるために用意した配列
int dx[6] = {-1, 1,  0,  0,  0,  0};
int dy[6] = { 0, 0, -1,  1,  0,  0};
int dz[6] = { 0, 0,  0,  0, -1,  1};

typedef vector<vector<int> > vv_int;
typedef vector<vv_int > vvv_int;

// 過去に来たことがあるか確認するための関数
bool havePos(const vv_int &hist, const vector<int> &pos){
    int size = hist.size();
    for(int i=0; i<size; ++i){
	vector<int> now_pos = hist[i];
	if(now_pos[0]==pos[0] && now_pos[1]==pos[1] && now_pos[2]==pos[2])
	    return true;
    }
    return false;
}

// ライトをひとつ広げるための処理
void passLight(vvv_int &cube, int color, vector<int> &pos, vv_int &hist, int &total, vector<int> &res, int depth){
    if(depth==0)
	return ;
    hist.push_back(pos);
    int &x=pos[0], &y=pos[1], &z=pos[2];
    if(cube[x][y][z]==-1){
	cube[x][y][z] = color;
	total += 1;
	res[color] +=1;
    }
    else if(cube[x][y][z]==color){
	for(int i=0; i<6; ++i){
	    int x_ = x+dx[i], y_ = y+dy[i], z_ = z+dz[i];
//	    x += dx[i]; y += dy[i]; z += dz[i];
	    int size = cube.size();
	    if(x_ < 0 || size <= x_) continue;
	    if(y_ < 0 || size <= y_) continue;
	    if(z_ < 0 || size <= z_) continue;
	    vector<int> next = {x_, y_, z_};
	    if(havePos(hist, next)) continue;
	    passLight(cube, color, next, hist, total, res, depth-1);
	}
    }
}

// デバッグ用。キューブの状態と一回のwhileで訪れたマスを標準出力する
void debug(vvv_int &cube, vv_int &h, int N){
    for(int i=0; i<N; ++i){
	for(int j=0; j<N; ++j){
	    for(int k=0; k<N; ++k){
		if(cube[i][j][k]==-1)
		    cout << " . ";
		else if(cube[i][j][k]<10)
		    cout << " " << cube[i][j][k] << " ";
		else
		    cout << cube[i][j][k] << " ";
	    }
	    cout << endl;
	}
	cout << "##########" << endl;
    }
//    for(int i=0; i<h.size(); ++i)
//	printf("(%d,%d,%d)" ,h[i][0], h[i][1], h[i][2]);
//    cout << endl;
    cout << "******************************" <<endl;
}

class LightsCube {
public:
	vector <int> count(int N, vector <string> lights) {
	    // キューブの状態。全て-1で初期化
	    vvv_int cube(N, vector<vector<int> >(N, vector<int>(N, -1)));
	    vector<vector<int> > pos; 
	    int size = lights.size(), total=size;
	    vector<int> res(size, 1);

	    // ライトの位置を扱いやすいようvector<vector<int>>へ変換
	    for(int i=0; i<size; ++i){
		int x,y,z;
		sscanf(lights[i].c_str(), "%d %d %d", &x, &y, &z);
		cube[x][y][z] = i;
		vector<int> xyz = {x, y, z};
		pos.push_back(xyz);
	    }

	    vv_int right_history;
	    while(total<N*N*N){
		for(int i=0; i<size; ++i){
		    right_history.clear();
		    passLight(cube, i, pos[i], right_history, total, res, N*N*N+1);
		}
	    debug(cube, right_history, N);
	    }
	    return res;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <string> p1, bool hasAnswer, vector <int> p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	LightsCube *obj;
	vector <int> answer;
	obj = new LightsCube();
	clock_t startTime = clock();
	answer = obj->count(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		if (answer.size() != p2.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p2[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
		if (hasAnswer) {
			cout << "Desired answer:" << endl;
			cout << "\t" << "{";
			for (int i = 0; int(p2.size()) > i; ++i) {
				if (i > 0) {
					cout << ",";
				}
				cout << p2[i];
			}
			cout << "}" << endl;
		}
		cout << "Your answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(answer.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << answer[i];
		}
		cout << "}" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	vector <string> p1;
	vector <int> p2;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 12;
	p1 = {"4 7 6","8 0 0","3 2 3","7 7 2","7 5 1","10 11 5","4 9 7","6 1 0","10 1 1","9 7 11","11 3 11","9 0 3","10 2 0"};
	p2 = {264,18,303,236,105,124,216,44,53,146,126,80,13};
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 3;
	p1 = {"1 1 1"};
	p2 = {27};
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 2;
	p1 = {"0 0 0","0 0 1","0 1 0","0 1 1","1 0 0","1 0 1","1 1 0","1 1 1"};
	p2 = {1,1,1,1,1,1,1,1};
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 5;
	p1 = {"0 2 4","2 0 0","3 4 4","4 1 2"};
	p2 = {38,28,32,27};
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 4;
	p1 = {"0 0 0","3 3 3"};
	p2 = {32,32};
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = 40;
	p1 = {"29 13 9","4 10 34","11 26 16","2 33 22","27 31 14","36 20 8"};
	p2 = {14657,12834,12364,5902,12678,5565};
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You have received a nice gift from a friend.  It consists of some colored lights arranged in a N x N x N cube, with a light at every slot inside the cube.  The position of each light is described by three coordinates (x, y, z) where x, y and z are non-negative integers less than N.  The light in position (x, y, z) is adjacent to the lights at positions (x-1, y, z), (x+1, y, z), (x, y-1, z), (x, y+1, z), (x, y, z-1) and (x, y, z+1) (when these lights exist).  Initially some lights (at least one) are turned on.  During each second, all turned off lights adjacent to a turned on light are switched on and take its color.  If a light is adjacent to more than one turned on light, it takes the lower number color.  This process continues until all the lights are on.
// 
// You are given an int N and a vector <string> lights.  The i-th element of lights is formatted as "x y z" (quotes for clarity only) and describes the position of the light of color i.  Return a vector <int> with the same number of elements as lights, the i-th element of which represents the number of lights of color i after the process described above ends.
// 
// 
// DEFINITION
// Class:LightsCube
// Method:count
// Parameters:int, vector <string>
// Returns:vector <int>
// Method signature:vector <int> count(int N, vector <string> lights)
// 
// 
// CONSTRAINTS
// -N will be between 1 and 40, inclusive.
// -lights will contain between 1 and 50 elements, inclusive.
// -Each element of lights will be in the form "x y z" (quotes for clarity) where x, y and z are integers between 0 and N-1, inclusive, with no leading zeroes.
// -The positions in lights will be distinct.
// 
// 
// EXAMPLES
// 
// 0)
// 2
// {"0 0 0", "0 0 1", "0 1 0", "0 1 1", "1 0 0", "1 0 1", "1 1 0", "1 1 1"}
// 
// Returns: {1, 1, 1, 1, 1, 1, 1, 1 }
// 
// Initially all lights are on.  Therefore, we end with one light of each color.
// 
// 1)
// 3
// {"1 1 1"}
// 
// Returns: {27 }
// 
// There is only 1 light turned on, so all other 26 lights will take its color. Six lights are turned on during the first second, twelve during the second one and the last eight are turned on during the third second.
// 
// 2)
// 4
// {"0 0 0", "3 3 3"}
// 
// Returns: {32, 32 }
// 
// The lights turned on are at opposite corners.  There will never be a turned off light adjacent to lights of different colors, so we end up with an equal number of lights of each color.
// 
// 3)
// 5
// {"0 2 4", "2 0 0", "3 4 4", "4 1 2"}
// 
// Returns: {38, 28, 32, 27 }
// 
// A turned off light might be adjacent to lights of different colors.  For example, just before it turns on, the light at position (4, 3, 3) will be adjacent to lights of the last two colors.  It will take the third color.
// 
// 4)
// 12
// {"4 7 6", "8 0 0", "3 2 3", "7 7 2", "7 5 1",
//  "10 11 5", "4 9 7", "6 1 0", "10 1 1", "9 7 11",
//  "11 3 11", "9 0 3", "10 2 0"}
// 
// Returns: {264, 18, 303, 236, 105, 124, 216, 44, 53, 146, 126, 80, 13 }
// 
// 
// 
// 5)
// 40
// {"29 13 9", "4 10 34", "11 26 16", "2 33 22", "27 31 14", "36 20 8"}
// 
// Returns: {14657, 12834, 12364, 5902, 12678, 5565 }
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
